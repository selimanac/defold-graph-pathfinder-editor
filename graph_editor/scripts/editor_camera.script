--FROM: https://defold.com/examples/render/orbit_camera/

-- The initial zoom level
go.property("zoom", 3)
-- The speed of the zoom
go.property("zoom_speed", 0.01)
-- The speed of the rotation
go.property("rotation_speed", 0.5)
-- The speed of the camera movement
go.property("movement_speed", 4)
-- The offset of the camera from the origin
go.property("offset", vmath.vector3(0, 0, 0))

local const    = require("graph_editor.scripts.editor_const")
local data     = require("graph_editor.scripts.editor_data")

local defaults = {}

function init(self)
	-- Acquire input focus to receive input events
	msg.post(".", "acquire_input_focus")

	-- Initialize start values
	self.yaw               = go.get(".", "euler.y")
	self.pitch             = go.get(".", "euler.x")
	self.zoom_offset       = 0
	self.current_yaw       = self.yaw
	self.current_pitch     = self.pitch
	self.current_zoom      = self.zoom_offset
	data.camera_zoom       = self.zoom

	defaults.yaw           = go.get(".", "euler.y")
	defaults.pitch         = go.get(".", "euler.x")
	defaults.zoom_offset   = 0
	defaults.current_yaw   = self.yaw
	defaults.current_pitch = self.pitch
	defaults.current_zoom  = self.zoom_offset
	defaults.camera_zoom   = self.zoom
	defaults.offset        = self.offset

	-- Movement state
	self.move_forward      = false
	self.move_backward     = false
	self.move_left         = false
	self.move_right        = false
end

function update(self, dt)
	-- Apply camera movement based on pressed keys
	if self.move_forward or self.move_backward or self.move_left or self.move_right then
		local movement = vmath.vector3(0, 0, 0)

		-- Calculate movement direction relative to camera's yaw
		local yaw_rad = math.rad(self.yaw)
		local forward = vmath.vector3(math.sin(yaw_rad), 0, math.cos(yaw_rad))
		local right = vmath.vector3(math.cos(yaw_rad), 0, -math.sin(yaw_rad))

		-- Accumulate movement from all pressed keys
		if self.move_forward then
			movement = movement - forward
		end
		if self.move_backward then
			movement = movement + forward
		end
		if self.move_left then
			movement = movement - right
		end
		if self.move_right then
			movement = movement + right
		end

		-- Normalize and apply movement speed
		if vmath.length_sqr(movement) > 0 then
			movement = vmath.normalize(movement) * self.movement_speed * dt
			self.offset = self.offset + movement
		end
	end

	-- Animate camera rotation and zoom
	self.current_yaw      = vmath.lerp(0.15, self.current_yaw, self.yaw)
	self.current_pitch    = vmath.lerp(0.15, self.current_pitch, self.pitch)
	self.current_zoom     = vmath.lerp(0.15, self.current_zoom, self.zoom_offset)
	data.camera_zoom      = self.zoom + self.current_zoom

	-- Calculate rotation and position
	local camera_yaw      = vmath.quat_rotation_y(math.rad(self.current_yaw))
	local camera_pitch    = vmath.quat_rotation_x(math.rad(self.current_pitch))
	local camera_rotation = camera_yaw * camera_pitch
	local camera_position = self.offset + vmath.rotate(camera_rotation, vmath.vector3(0, 0, self.zoom + self.current_zoom))

	-- Set camera position and rotation
	go.set_position(camera_position)
	go.set_rotation(camera_rotation)
end

function on_input(self, action_id, action)
	if data.want_mouse_input then -- Mouse on imgui window
		return
	end

	if action_id == const.TRIGGERS.MOUSE_BUTTON_RIGHT and not action.pressed then
		self.yaw   = self.yaw - action.dx * self.rotation_speed
		self.pitch = self.pitch + action.dy * self.rotation_speed
	elseif action_id == const.TRIGGERS.MOUSE_WHEEL_UP then
		self.zoom_offset = self.zoom_offset - self.zoom * self.zoom_speed
	elseif action_id == const.TRIGGERS.MOUSE_WHEEL_DOWN then
		self.zoom_offset = self.zoom_offset + self.zoom * self.zoom_speed
		-- Handle movement keys - W/UP for forward
	elseif action_id == const.TRIGGERS.KEY_W or action_id == const.TRIGGERS.KEY_UP then
		if action.released then
			self.move_forward = false
		else
			self.move_forward = true
		end
		-- Handle movement keys - S/DOWN for backward
	elseif action_id == const.TRIGGERS.KEY_S or action_id == const.TRIGGERS.KEY_DOWN then
		if action.released then
			self.move_backward = false
		else
			self.move_backward = true
		end
		-- Handle movement keys - A/LEFT for left
	elseif action_id == const.TRIGGERS.KEY_A or action_id == const.TRIGGERS.KEY_LEFT then
		if action.released then
			self.move_left = false
		else
			self.move_left = true
		end
		-- Handle movement keys - D/RIGHT for right
	elseif action_id == const.TRIGGERS.KEY_D or action_id == const.TRIGGERS.KEY_RIGHT then
		if action.released then
			self.move_right = false
		else
			self.move_right = true
		end
	end
end

function on_message(self, message_id, _, _)
	if message_id == hash("reset") then
		self.yaw = defaults.yaw
		self.pitch = defaults.pitch
		self.zoom_offset = defaults.zoom_offset
		self.current_yaw = defaults.current_yaw
		self.current_pitch = defaults.current_pitch
		self.current_zoom = defaults.current_zoom
		data.camera_zoom = defaults.camera_zoom
		self.offset = defaults.offset
		-- Reset movement state flags
		self.move_forward = false
		self.move_backward = false
		self.move_left = false
		self.move_right = false
	end
end
